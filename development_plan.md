# План разработки игры "Государь"

Этот документ описывает пошаговый план создания Telegram-бота для игры "Государь", основанный на описании из файла `the-king.md`.

## Этап 1: Подготовка и настройка проекта

1.  **Создание структуры проекта:**
    -   Создать все папки и файлы согласно архитектуре, описанной в `the-king.md`:
        -   `/game-bot` (корневая папка)
        -   `/bot`, `/game`, `/data`, `/events`, `/utils`
        -   Файлы `__init__.py` в каждой директории.
        -   Основные файлы: `bot/main.py`, `bot/handlers.py`, `game/core.py`, `game/events.py`, `game/mechanics.py`, `data/database.py`, `data/models.py`, `events/base.py`, `config.py`, `requirements.txt`, `README.md`.
2.  **Настройка окружения:**
    -   Создать и активировать виртуальное окружение (например, venv).
    -   Создать файл `requirements.txt` и добавить в него основные зависимости: `aiogram`, `supabase-py` (и здесь можно добавить питон, чтобы на сервере не было проблем с установкой).
    -   Установить зависимости: `pip install -r requirements.txt`.
3.  **Конфигурация:**
    -   Создать файл `config.py`.
    -   Добавить в него заглушки для токена Telegram-бота и данных для подключения к базе данных (Supabase URL/key или параметры SQLite).
    -   Настроить `.gitignore` для исключения виртуального окружения, файлов конфигурации с секретами и т.п.

## Этап 2: Реализация базовой игровой логики

1.  **Основные классы (`game/core.py`):**
    -   Создать класс `Country` с атрибутами: `support`, `treasury`, `army`, `peasants`.
    -   Реализовать метод `update` для изменения показателей страны.
    -   Создать класс `Player` (пока можно с минимальными полями, например, `telegram_id` и объект `Country`).
2.  **Механики (`game/mechanics.py`):**
    -   Определить логику взаимосвязи показателей (например, как изменение армии влияет на крестьян и казну).
    -   Начать с простой реализации (например, строковые значения "low", "medium", "high" для армии/крестьян), позже можно усложнить.

## Этап 3: Базовая структура событий

1.  **Базовый класс события (`events/base.py`):**
    -   Создать класс `Event` с атрибутами: `description` (описание события), `options` (словарь с вариантами выбора и их эффектами).
    -   Реализовать метод `apply`, который принимает выбор игрока и объект `Country` и применяет эффекты.
2.  **Генерация событий (`game/events.py`):**
    -   Создать функцию `get_next_event(country)`, которая пока будет возвращать одно тестовое событие.
    -   Создать пару тестовых событий (можно прямо в этом файле или в `events/random.py`) для проверки.

## Этап 4: Интеграция с Telegram-ботом

1.  **Инициализация бота (`bot/main.py`):**
    -   Настроить инициализацию `Bot` и `Dispatcher` из `aiogram`.
    -   Подключить обработчики из `handlers.py`.
    -   Реализовать запуск бота (`executor.start_polling`).
2.  **Обработчики команд и кнопок (`bot/handlers.py`):**
    -   Реализовать обработчик команды `/start`:
        -   Создание нового объекта `Country` для игрока.
        -   (Пока без сохранения в БД) Получение первого события через `get_next_event`.
        -   Отправка сообщения с описанием события и кнопками (`InlineKeyboardMarkup`).
    -   Реализовать обработчик нажатий на кнопки (`callback_query_handler`):
        -   Получение выбора игрока из `callback_data`.
        -   (Пока без загрузки из БД) Применение эффектов события с помощью `event.apply`.
        -   Получение следующего события.
        -   Редактирование сообщения (`edit_text`) с новым событием и кнопками.

## Этап 5: Работа с базой данных

1.  **Модели данных (`data/models.py`):**
    -   Определить структуру таблиц (например, `players`, `countries`) с использованием SQLAlchemy Core или Pydantic моделей для Supabase.
2.  **Подключение и запросы (`data/database.py`):**
    -   Реализовать функции для подключения к выбранной БД (Supabase или SQLite).
    -   Создать асинхронные функции:
        -   `save_player_state(player_id, country_data)`: сохраняет состояние страны игрока.
        -   `load_player_state(player_id)`: загружает состояние страны игрока.
        -   `get_or_create_player(player_id)`: получает или создает игрока при старте.
3.  **Интеграция с обработчиками:**
    -   Добавить вызовы функций `save_player_state` и `load_player_state` в `bot/handlers.py` (в `start_command` и `button_callback`).

## Этап 6: Расширение системы событий

1.  **Разные типы событий (`events/random.py`, `events/seasonal.py`, `events/conditional.py`):**
    -   Создать конкретные классы событий, наследующиеся от `Event`.
    -   Наполнить файлы разными событиями с их описаниями и эффектами.
2.  **Усложнение логики генерации (`game/events.py`):**
    -   Модифицировать `get_next_event`, чтобы она выбирала событие на основе вероятности, состояния страны (`country`) и, возможно, истории событий.

## Этап 7: Условия завершения игры и управление сообщениями

1.  **Проверка условий завершения:**
    -   В `button_callback` после применения эффектов добавить проверку показателей `Country` (поддержка <= 0, казна <= 0 и т.д.).
2.  **Логика конца игры:**
    -   Если игра окончена, отправить сообщение о причине "смерти" и итоговых результатах (например, сколько ходов продержался).
    -   Предложить начать заново кнопкой.
3.  **Удаление сообщений:**
    -   Реализовать механизм отслеживания ID сообщений бота для конкретного игрока.
    -   При старте новой игры (после завершения предыдущей) удалять все предыдущие сообщения бота в чате.

## Этап 8: Доработка и тестирование

1.  **Вспомогательные утилиты (`utils/`):**
    -   Настроить логирование (`logger.py`).
    -   Создать хелперы (`helpers.py`) для форматирования сообщений, генерации клавиатур и т.п., если потребуется.
2.  **Тестирование:**
    -   Протестировать все механики, события, переходы состояний, сохранение/загрузку.
    -   Проверить корректность удаления сообщений.
3.  **Рефакторинг и документация:**
    -   Просмотреть код, улучшить читаемость, добавить комментарии где необходимо.
    -   Обновить `README.md` с инструкциями по запуску и описанием.

Этот план можно будет корректировать по ходу разработки. 